<!-- This file was automatically generated from Markdown or JSON source files.
     DO NOT edit this file directly but look for the according source file! --><!DOCTYPE html><html><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><link href="/static/css/docs.css" rel="stylesheet"><title>Emojicode Documentation &middot; The Package API</title></head><body><nav class="menu" role="navigation"><a href="/" class="menu-logo">Emojicode</a><div class="menu-right"><a href="&#x2F;docs&#x2F;" class="active">Documentation</a> <a href="https://github.com/emojicode">GitHub</a></div></nav><header class="docs-header"><a href="&#x2F;docs&#x2F;" class="docs-header-title">Emojicode Documentation <span class="docs-header-version">0.5</span></a><div class="docs-header-right"><a href="&#x2F;docs&#x2F;guides" class="active">Guides</a> <a href="&#x2F;docs&#x2F;reference">Language Reference</a> <a href="&#x2F;docs&#x2F;packages">Package Index</a></div></header><div class="content"><div class="toc-wrapper"><div class="toc"><h2>Guides</h2><ol data-gumshoe><li><a href="install.html" class="chapter-link">Installing Emojicode</a></li><li><a href="compile-and-run.html" class="chapter-link">Compile and Run Your First Program</a></li><li><a href="input-methods.html" class="chapter-link">Input methods</a></li><li><a href="allegro.html" class="chapter-link">The Cookie Monster Game</a></li><li><a href="packageAPI.html" class="chapter-link current">The Package API</a><ul><li><a href="#native-binaries" class="section-link">Native Binaries</a></li><li><a href="#run-time-native-linking" class="section-link">Run-Time Native Linking</a></li><li><a href="#minimal-setup" class="section-link">Minimal Setup</a></li><li><a href="#preparing-a-class" class="section-link">Preparing a class</a></li><li><a href="#using-the-package-api" class="section-link">Using the Package API</a></li><li><a href="#clashing-with-the-garbage-collector" class="section-link">Clashing with the Garbage Collector</a></li><li><a href="#compiling-the-package" class="section-link">Compiling The Package</a></li><li><a href="#deinitialization" class="section-link">Deinitialization</a></li><li><a href="#marking" class="section-link">Marking</a></li></ul></li></ol></div></div><h1 id="the-package-api">The Package API</h1><p>The package API allows to write a package whose logic can be implemented in C++. This allows you to expand Emojicode‚Äôs capabilities, like accessing special system APIs.</p><p>Make sure that you have read <a href="../reference/packages.html">Packages</a> and understand how packages work.</p><div class="callout-hint"><div class="title">Hint</div><div class="text"><p>This guide is work in progress.</p></div></div><h2 id="native-binaries">Native Binaries</h2><p>Native binaries are dynamic libraries, which are always suffixed <code>.so</code>, and are placed alongside the package‚Äôs <code>header.emojic</code> in its directory. If the cat simulator from previous examples used a native binary, the Package Search Path would look something like:</p><pre><code>...
‚îú‚îÄ‚îÄ cat-simulator -&gt; /usr/local/EmojicodePackages/cat-simulator-v0
‚îî‚îÄ‚îÄ cat-simulator-v0
    ‚îú‚îÄ‚îÄ cat-simulator.so
    ‚îî‚îÄ‚îÄ header.emojic
</code></pre><h2 id="run-time-native-linking">Run-Time Native Linking</h2><p>When starting up and loading a program, the Real-Time Engine dynamically loads the static library and basically links all methods of your package with the corresponding functions from the dynamic library.</p><p>Your package must provide a so-called linking table. The linking table is simply a long list of functions. The Real-Time Engine then links these functions by looking up an index provided with üìª at a method declaration. You&#39;ll learn more about this in a minute. This procedure is called <em>Run-Time Native Linking</em>.</p><h2 id="minimal-setup">Minimal Setup</h2><p>To get started import the API header of the latest Emojicode version:</p><pre><code class="lang-C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"EmojicodeReal-TimeEngine/EmojicodeAPI.hpp"</span></span>
</code></pre><p>This header defines some of the interfaces you will use. For specific tasks, however, you‚Äôll have to include additional headers.</p><h3 id="version-linking-table-class-preparation">Version, Linking Table, Class Preparation</h3><p>Your package must provide the following symbols:</p><pre><code class="lang-C++">Emojicode::<span class="hljs-function">PackageVersion <span class="hljs-title">version</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span></span>;

LinkingTable {

};

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepareClass</span><span class="hljs-params">(Emojicode::Class *klass, EmojicodeChar name)</span> </span>{

}
</code></pre><p>The purpose of <code>version</code> should be pretty obvious: It represents the version of the package. The Real-Time Engine uses this value for verification.</p><p><code>LinkingTable</code> is actually a macro that expands to an array definition. You‚Äôre going to list C++ functions that will be the function bodies of methods or initializers available from Emojicode in this array.</p><p><code>prepareClass</code> is a function that is called for every class defined in your package. This is the place where you have to setup the class and this is also your chance to store the class pointer somewhere for later use (e.g. allocating an object of a class).</p><h2 id="preparing-a-class">Preparing a class</h2><p>To see how preparing classes work, let‚Äôs have a look at the sockets package‚Äôs <code>prepareForClass</code>:</p><pre><code class="lang-C++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">prepareClass</span><span class="hljs-params">(Emojicode::Class *klass, EmojicodeChar name)</span> </span>{
    <span class="hljs-keyword">switch</span> (name) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0x1f3c4</span>: <span class="hljs-comment">//üèÑ</span>
            klass-&gt;valueSize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">0x1f4de</span>: <span class="hljs-comment">//üìû</span>
            CL_SOCKET = klass;
            klass-&gt;valueSize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre><p>You can see that a switch statement has been used to identify the class that was passed to the function and that the <code>valueSize</code> member of the classes are set. This variable specifies the amount of space Emojicode will additionally (in addition to the basic size of the object and its instance variables) allocate. This space is called <em>value area</em> and can be used to store custom data. The sockets package uses the value area to store file descriptors there, which have the size of an integer.</p><p>You‚Äôll also note that one of the classes was assigned to a global variable: <code>CL_SOCKET = klass;</code>. If you need any of the classes, for instance to allocate an instance of it later, it‚Äôs important that you keep save it somewhere. The socket package uses a global variable. E.g.</p><pre><code class="lang-C++"><span class="hljs-keyword">static</span> Emojicode::Class *CL_SOCKET;

<span class="hljs-comment">// ...</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serverAccept</span><span class="hljs-params">(Thread *thread)</span> </span>{
    <span class="hljs-comment">// ...</span>
    Emojicode::Object *socket = newObject(CL_SOCKET);
    <span class="hljs-comment">// ...</span>
}
</code></pre><h2 id="using-the-package-api">Using the Package API</h2><p>First of all, let‚Äôs have a look at a socket initializer. A fair amount of crazy POSIX socket stuff is going on here; it has partly been removed and we‚Äôll just ignore what‚Äôs left and focus on the package API calls.</p><pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">socketInitWithHost</span><span class="hljs-params">(Thread *thread)</span> </span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host = Emojicode::stringToCString(thread-&gt;variable(<span class="hljs-number">0</span>).object);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">server</span> = <span class="hljs-title">gethostbyname</span>(<span class="hljs-title">host</span>);</span>
    <span class="hljs-keyword">if</span> (server == <span class="hljs-literal">nullptr</span>) {
        thread-&gt;returnErrorFromFunction(errnoToError());
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// ... crazy POSIX socket stuff ...</span>

    <span class="hljs-keyword">int</span> socketDescriptor = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (socketDescriptor == <span class="hljs-number">-1</span> || connect(socketDescriptor <span class="hljs-comment">/* ... */</span>) {
        thread-&gt;returnErrorFromFunction(errnoToError());
        <span class="hljs-keyword">return</span>;
    }
    *thread-&gt;thisObject()-&gt;val&lt;<span class="hljs-keyword">int</span>&gt;() = socketDescriptor;
    thread-&gt;returnOEValueFromFunction(thread-&gt;thisObject());
}
</code></pre><p>This initializers shows off a few important aspect of writing a package function:</p><ul><li><p>First of all, a package function always returns void and takes one parameter of type <code>Thread *</code>. It‚Äôs a convention to name it <code>thread</code>.</p></li><li><p>On the first line of the function you can see that the function <code>stringToCString</code> is used to convert an Emojicode string object to a <code>const char*</code>. This method uses the Emojicode memory allocator and its return must not be freed.</p></li><li><p>You can see that the argument that‚Äôs passed to <code>stringToCString</code> is the content of a variable: <code>thread-&gt;variable(0).object</code>. This variable represents the first argument. All arguments are stored on the stack in the order they are passed to the function. The first argument is therefore always at index 0. Note that these indexes actually represent stack indexes and are measured in Emojicode words. We‚Äôll talk about that in detail shortly.</p><p>Just remember for now, that <code>thread-&gt;variable</code> returns a <code>Value</code>.</p></li><li><p>You can see that in case of an error (if <code>server</code> is an null pointer), the method <code>returnErrorFromFunction</code> is called on the thread. It‚Äôs used to return an error value from a function. We‚Äôll talk about returning in a second too.</p></li><li><p><code>*thread-&gt;thisObject()-&gt;val&lt;int&gt;() = socketDescriptor;</code> is interesting as well. Here the current object‚Äôs value area is accessed. The <code>val&lt;T&gt;()</code> method returns a pointer to the value area as a pointer to <code>T</code>. The <code>socketDescriptor</code> value is then written to that pointer.</p></li><li><p>Finally, the method <code>thread-&gt;returnOEValueFromFunction</code> is called and the method object is returned.</p></li></ul><p>The next sections will cover theses APIs in detail.</p><h3 id="value-and-the-emojicode-word">Value and the Emojicode Word</h3><p>In Emojicode every value you‚Äôll work with will come wrapped into a <code>Value</code> and you‚Äôll have to wrap it in a value when you pass it to Emojicode. Conveniently, wrapping often takes place implicitly with these constructors:</p><pre><code class="lang-C++"><span class="hljs-keyword">union</span> Value {
    <span class="hljs-comment">// ...</span>
    Value(<span class="hljs-keyword">bool</span> raw) : raw(raw) {}
    Value(Object *object) : object(object) {}
    Value(<span class="hljs-keyword">double</span> doubl) : doubl(doubl) {}
    <span class="hljs-comment">// ...</span>
};
</code></pre><p>As you can see <code>Value</code> is just a union and has various data members:</p><pre><code class="lang-C++">EmojicodeInteger raw;
EmojicodeChar character;
<span class="hljs-keyword">double</span> doubl;
Object *object;
Class *klass;
Value *value;
</code></pre><p>You can use them to access the value inside the <code>Value</code> like the function above did, but be carefully to only use the matching member, i.e. only use <code>doubl</code> when the value actually represents a double.</p><p>Emojicode measures the size of types in Emojicode words, which are normally 64-bit. <code>Value</code> represent a value that is exactly one Emojicode word long. Note that the Emojicode Engine can only operate with values that are exactly one word long. That‚Äôs also the reason why <code>Value</code> is used all the time.</p><h3 id="the-stack">The Stack</h3><p>It‚Äôs important that you understand how the Emojicode stack works. You‚Äôll normally only use it to get the arguments passed to your function. The important methods for it are:</p><pre><code class="lang-C++"><span class="hljs-function">Value <span class="hljs-title">variable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> *variableDestination(index); }
<span class="hljs-function">Value* <span class="hljs-title">variableDestination</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> <span class="hljs-keyword">const</span></span>;
</code></pre><p>The body of <code>variable</code> has been included to show, that it just dereferences the return of <code>variableDestination</code>.</p><p>When retrieving an argument you must calculate its index by summing up all sizes of the preceding arguments. Primitives (boolean, integers, symbols, object references) are exactly one word long. Optionals and error types are one word larger than the contained value. All other types have the size of summing up all instance variables.</p><p>You can also ask the compiler for the index of a variable by using the <code>-S</code> command line option. E.g.</p><pre><code class="lang-bash">emojicodec -S üçïü§ïp0 v7.emojic
</code></pre><p>would print</p><pre><code>‚ÑπÔ∏è Variable p0 is 6 words large and has index 10
</code></pre><h3 id="returning">Returning</h3><p>To return from a function you have to call an appropriate return function.</p><div class="callout-hint"><div class="title">Hint</div><div class="text"><p>It‚Äôs crucial that you call a return function before your C++ function actually returns.</p></div></div><p>The thread class provides several return methods:</p><pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnFromFunction</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnFromFunction</span><span class="hljs-params">(Value value)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnNothingnessFromFunction</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnOEValueFromFunction</span><span class="hljs-params">(Value value)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnErrorFromFunction</span><span class="hljs-params">(EmojicodeInteger error)</span></span>;
</code></pre><p>The first method is to be used when you didn‚Äôt declare that the method returns anything. The second one should be used when you returned a simple return value like a string, integer or boolean. <code>returnOEValueFromFunction</code> must be used when the declared return of the function is an error or optional and you want to return the contained type, i.e. no error occurred and you do not want to return nothingness. If you want to return nothingness and declared the return type as optional you should use <code>returnNothingnessFromFunction</code>. If you need to indicate an error use <code>returnErrorFromFunction</code>, to which you need to pass the value of the error enumeration instance you want to pass.</p><h2 id="clashing-with-the-garbage-collector">Clashing with the Garbage Collector</h2><p>One thing that is really important when creating a package binary is to take of the Garbage Collector. While we all love the Garbage Collector, it may become your enemy when creating a package binary.</p><h3 id="invocation-of-the-garbage-collector">Invocation of the Garbage Collector</h3><p>The Garbage Collector in Emojicode can be invoked when performing any of these actions, which we call <em>Garbage Collector Invoking Action</em> (abbr. GCIA):</p><ul><li>Allocating memory</li><li>Calling a callable or method</li><li>any other function that performs any of the actions above; refer to the documentation in the header files</li></ul><p>The Garbage Collector will invalidate any object to which it cannot find a reference. The Garbage Collector is, of course, not capable of detecting any reference to objects you held in C++ variables. Hence you must store all object references at a safe place before performing a GCIA, which is achieved by retaining.</p><h3 id="retaining-objects">Retaining Objects</h3><p>There are two important Thread methods for retaining and releasing objects:</p><pre><code class="lang-C++"><span class="hljs-function">RetainedObjectPointer <span class="hljs-title">retain</span><span class="hljs-params">(Object *object)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;
</code></pre><p>To retain an object, you pass it to <code>retain</code>. E.g.</p><pre><code class="lang-C++"><span class="hljs-keyword">auto</span> co = thread-&gt;retain(newArray(<span class="hljs-keyword">sizeof</span>(EmojicodeChar)));
</code></pre><p><code>RetainedObjectPointer</code> implements the <code>-&gt;</code> operator so you can and should use it as if it was an object pointer. Note that while the <code>RetainedObjectPointer</code> itself stays valid, pointers you get to values inside the object it points to, e.g. <code>co-&gt;val&lt;EmojicodeChar&gt;()</code> do not stay valid across garbage collector cycles. You should always retrieve them from the retained pointer after performing a GCIA.</p><p>When you no longer need the object you <strong>must</strong> release it by calling <code>release</code>:</p><pre><code class="lang-C++">thread-&gt;release(<span class="hljs-number">1</span>);
</code></pre><p>Not that retaining and relasing works like a stack, thats means the last object you retained will be released when calling <code>release</code>. You can release multiple retained objects at once by calling <code>release</code> with the number of objects you want to release.</p><div class="callout-hint"><div class="title">Hint</div><div class="text"><p>The Garbage Collector works in a special way: It copies all referenced, still required objects into a new space in memory. The ‚Äúoriginal‚Äù objects stay untouched temporarily. This can lead to very hard-to-track-down bugs if you are accidentally using a reference to the ‚Äúoriginal‚Äù but now invalidated object.</p></div></div><h3 id="garbage-collection-and-threading">Garbage Collection and Threading</h3><p>Garbage Collection in an multi-threaded environment like Emojicode requires further care. The Garbage Collector can only run while all threads are paused (‚Äústop the world‚Äù). While this will not affect you and your code usually, you should actually think about this when you implement time consuming activities. Unlike pure Emojicode functions, the Real-Time Engine has no control about your code and so it‚Äôs your task to ensure that your procedures does not block Garbage Collector cycles. If your procedure takes exceptionally long, you should consider using:</p><pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allowGC</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disallowGCAndPauseIfNeeded</span><span class="hljs-params">()</span></span>;
</code></pre><p>By calling <code>allowGC</code> you allow the Garbage Collector to run at any time while you are doing work. After the handler is finished with its work, it‚Äôs absolutely necessary to call <code>disallowGCAndPauseIfNeeded</code>.</p><div class="callout-caution"><div class="title">Caution</div><div class="text"><p>Between a call to <code>allowGC</code> and <code>disallowGCAndPauseIfNeeded</code> you <strong>must not perform any allocations or other kind of GCIA</strong> and you or any called function <strong>must not call <code>allowGC</code></strong> again. Additionally, the Garbage Collector might move any objects. Make sure you don‚Äôt rely <strong>on any</strong> ‚Äî not even those retained ‚Äî objects between these two function calls.</p></div></div><p>For the sake of completeness, <code>void pauseForGC();</code> should be mentioned, which we recommend you rather not use. It‚Äôs exactly the function that is called between execution of different Emojicode instructions to determine whether a Garbage Collector pause was requested. Please see the header files for further information.</p><h2 id="compiling-the-package">Compiling The Package</h2><p>This should be agood starting point.</p><p><code>-undefined dynamic_lookup</code> is macOS only, remove it for any other OS.</p><pre><code class="lang-bash">g++ -O3 -std=c++14 -fPIC -c your_package.c -o your_package.o
g++ -shared -fPIC -undefined dynamic_lookup your_package.o -o your_package.so
</code></pre><p>If you don‚Äôt shrink from using a build system like CMake, make sure to also check out how the files package etc. are built in the Emojicode main repository.</p><h2 id="deinitialization">Deinitialization</h2><p>In some cases you&#39;ll work with resources that need to be freed after they are no longer used. Often you‚Äôll then offer an API and let the user do the freeing himself. However, it‚Äôs can be desirable to free or ensure the resource was freed, when the Garbage Collector abandons an object.</p><p>You can register an object for deinitalization with this function:</p><pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerForDeinitialization</span><span class="hljs-params">(Object *object)</span></span>;
</code></pre><p>You must have provided a deinitializer for the object‚Äôs class (set <code>klass-&gt;deinit</code> in <code>prepareClass</code>).</p><p>Note that deinitalization should only be considered a fall back as there‚Äôs no guarantee the garbage collector will ever be triggered while the program is running.</p><h2 id="marking">Marking</h2><p>It is also very important that you set an appropriate marking function if you store object pointers in the value area. To set a marking function for a class, assign it‚Äôs <code>mark</code> member variable to the function.</p><div class="callout-caution"><div class="title">Caution</div><div class="text"><p>It‚Äôs important that you write a proper marker function when your class stores references to objects in its value area.</p></div></div><p>The marker is a function that is called by the garbage collector when it inspects an object and copies it into a new location in memory. This function must call appropriate members of the mark family for every objects reference. The mark functions are:</p><pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mark</span><span class="hljs-params">(Object **of)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">markValueReference</span><span class="hljs-params">(Value **valuePointer)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">markBox</span><span class="hljs-params">(Box *box)</span></span>;
</code></pre><p><code>mark</code> must be used when you have stored a simple object pointer. Pass it a pointer to where the pointer is actually located in memory.</p><p>You must call <code>markValueReference</code> when you store a reference to a value type instance and pass it a pointer to where the reference is stored. Note that this is only necessary with value type references. It‚Äôs unlikely you‚Äôre every going to deal with them.</p><p>Finally, you must call <code>markBox</code> with a pointer to the box to mark it. This is necessary because a box might store it‚Äôs content remotely and a value type contained in the box might keep an object reference itself.</p><p>Below you can see part of üç®‚Äôs marking function:</p><pre><code class="lang-C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">listMark</span><span class="hljs-params">(Object *self)</span> </span>{
    <span class="hljs-keyword">auto</span> *<span class="hljs-built_in">list</span> = self-&gt;val&lt;List&gt;();
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>-&gt;items) {
        mark(&amp;<span class="hljs-built_in">list</span>-&gt;items);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">list</span>-&gt;count; i++) {
        markBox(&amp;<span class="hljs-built_in">list</span>-&gt;elements()[i]);
    }
}
</code></pre><div class="book-navigation-bottom"><a href="allegro.html" class="left">‚Üê Previous</a></div><div class="book-improve">Want to improve this page? <a href="https://github.com/emojicode/emojicode.github.io/blob/master/src&#x2F;guides&#x2F;packageAPI.md" target="_blank">You can edit the source on GitHub and send us a pull request!</a></div></div><script src="/static/js/gumshoe.min.js"></script><script>gumshoe.init({ activeClass: 'current', offset: 80 });</script><script>!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);loadCSS('http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/xcode.min.css');</script></body></html>